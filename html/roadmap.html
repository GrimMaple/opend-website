<main>
<h1>Stuff i might do in my D fork</h1>

<h2>Guaranteed</h2>

<ul>
	<li>Merge interpolated expressions (done jan 2, 2024)</li>
	<li>Change the automatic module name procedure in dmd to change - to _</li>
	<li>Remove -preview=bitfields</li>
	<li>Correct -release</li>
	<li>Make a way to detect the fork</li>
	<li>__traits(docComment)</li>
	<li>increase the size of the default fiber stack</li>
</ul>

<h2>Probably, if easy</h2>

<ul>
	<li>Bring 0o777 octal literals back (done jan 4, 2024)</li>
	<li>Fix the closure bug in foreach loops</li>
	<li>tg's tuple work</li>
	<li>Class-level private (in addition to the current module-level private)</li>
	<li>Merge Jonathan Marler's wrongfully rejected bug fixes re module system ref: https://github.com/dlang/dmd/pull/7878 and https://github.com/dlang/dmd/pull/7778</li>
	<li>Merge mixinC ref https://github.com/dlang/dmd/pull/14114</li>
	<li>Switch to safe by default</li>
	<li>Bring in some kind of assert(__ctfe) detection ref: https://github.com/dlang/dmd/pull/11007/</li>
	<li>Allow inferring of other attributes as well as turning them back off, assuming i don't just kill them as useless bloat no-ops. Probably add opposite things (throw, impure, etc) as well as `@!thing` which just removes thing, if present, from the list. Works for compiler attributes as well as user defined attributes (and btw maybe there should be no compiler attributes and they all just recognized UDAs)</li>
	<li>Fix phobos lol prolly not ez</li>
	<li>Fix pragma(linkerDirective) on mac</li>
	<li>Fix error messages gagging things and just giving void as the type in delegates and such</li>

	<li>const(Object) o ref for rebindable const object https://github.com/dlang/dmd/pull/3</li>
	<li>Fix package.d</li>
	<li>Ban user-redefined init</li>
	<li>Implicit construction (at least on return values)</li>
	<li>Eliminate Object.factory</li>
</ul>

<h2>Undecided, but maybe</h2>

<ul>
	<li>Return the thing if it is not a certain type or use it if it is, like rust error handling</li>
	<li>Implicit cast</li>
	<li>Template reflection</li>
	<li>Make Error call stack unwinders again</li>
	<li>Revisit bool/int and char/int conversions</li>
	<li>Revisit the enum-name-inference thing for all symbols in the namespace. Ref: https://github.com/dlang/dmd/pull/14650</li>
	<li>Change the distribution system so you have a compiler driver and it can install support packs for different things.
		<ul>
			<li>"Optimizer support pack" = ldc w/ ldmd2 (when you pass -O, it forwards the flags to that).</li>
			<li>"Cross compile support pack" = the runtime libraries and config stuff to enable the other platforms</li>
			<li>"Extended library pack" = a bunch of stuff from the dub ecosystem</li>
			<li>Windows resource file support made easy</li>
			<li>Etc.</li>
		</ul>
	</li>
	<li>Fix extern(Objective-C) in ldc</li>
	<li>Change built-in unittest to be a bit better</li>
	<li>Kill `version`</li>
	<li>Fix properties. This has been historically hard to implement though</li>
	<li>tg's __mutable</li>
	<li>https://github.com/dlang/phobos/pull/8806 json5 by robert schadek</li>
</ul>

<h2>Nope</h2>

<ul>
	<li>Focus on betterC or nogc. I might or might not deliberately break them, but I certainly won't expend effort maintaining or promoting them.</li>
</ul>

<h1>What could bring me back to upstream?</h1>

<p>Radical reform of process. There should never again be work left to rot. There has been a very long history of forks and abandoned contributors in D due to slow responses from Walter, going back at least as far as the Ares library that would later become Tango (and later, druntime).</p>

<p>Walter has taught us that in aviation engineering, yes, you try to have parts that are as reliable as reasonable possible, but you recognize that it is impossible for any one part to be perfect. Instead, the whole design of an airplane is based on the idea of avoid any single point of failure, including avoiding cascading or coincidental failures. You can make a reliable system out of unreliable parts.</p>

<p>For example, a commercial flight will always have two pilots, so if one gets sick or something, the other can still take over. They have separate controls, connected to the machinery by different paths, so if one side breaks, the other will almost certainly be ready to take over without delay. Pilot training has the crew cross-checking each other, so a mistake made by the captain will be caught and corrected by the first officer instead of blindly following orders.</p>

<p>D's current dictatorship model goes contrary to those lessons. Whether benevolent or not, a dictator is still a single point of failure and a bottleneck on the process. We need to correct this to finally allow D to thrive.</p>

<p>A few ideas:</p>

<ul>
	<li>Certain features could have different people in charge of it. Delegating responsibility would spread the work load and let domain specialists focus on their area of expertise without interference. This should be true for the language as well as for the library.</li>
	<li>Overall language direction could be guided in a formal process by all stakeholders, not subject to arbitrary reversion or hold by any one person.</li>
	<li>Language leaders must collaborate with contributors at all steps of the process. Even if an adversarial process is warranted in a particular situation, the requirements must be clearly laid out so a reasonable person can reliably estimate their chances of success before sinking a significant amount of time.</li>
</ul>
</main>
